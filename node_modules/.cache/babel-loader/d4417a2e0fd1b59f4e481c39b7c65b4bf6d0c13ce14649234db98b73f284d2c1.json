{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useRef, useEffect } from 'react';\n\n/**\n * Development-only hook to track component re-renders and detect excessive re-rendering\n * @param {string} componentName - Name of the component being tracked\n * @param {Object} props - Component props to track changes (optional)\n * @param {number} threshold - Number of renders before warning (default: 10)\n */\nconst useRenderTracker = (componentName, props = {}, threshold = 10) => {\n  _s();\n  const renderCount = useRef(0);\n  const lastRenderTime = useRef(Date.now());\n  const propsHistory = useRef([]);\n  const startTime = useRef(Date.now());\n  useEffect(() => {\n    // Only run in development mode\n    if (process.env.NODE_ENV !== 'development') {\n      return;\n    }\n    renderCount.current += 1;\n    const currentTime = Date.now();\n    const timeSinceLastRender = currentTime - lastRenderTime.current;\n    const totalTime = currentTime - startTime.current;\n\n    // Track props changes\n    const currentProps = {\n      ...props\n    };\n    const previousProps = propsHistory.current[propsHistory.current.length - 1] || {};\n\n    // Find changed props\n    const changedProps = {};\n    Object.keys(currentProps).forEach(key => {\n      if (currentProps[key] !== previousProps[key]) {\n        changedProps[key] = {\n          from: previousProps[key],\n          to: currentProps[key]\n        };\n      }\n    });\n\n    // Store current props for next comparison\n    propsHistory.current.push(currentProps);\n\n    // Keep only last 5 prop snapshots to prevent memory leaks\n    if (propsHistory.current.length > 5) {\n      propsHistory.current = propsHistory.current.slice(-5);\n    }\n\n    // Log render information\n    const hasChangedProps = Object.keys(changedProps).length > 0;\n    const logStyle = renderCount.current > threshold ? 'color: red; font-weight: bold;' : 'color: blue;';\n    console.log(`%cüîÑ ${componentName} rendered (#${renderCount.current})`, logStyle, {\n      renderCount: renderCount.current,\n      timeSinceLastRender: `${timeSinceLastRender}ms`,\n      totalTime: `${totalTime}ms`,\n      ...(hasChangedProps && {\n        changedProps\n      }),\n      ...(renderCount.current === 1 && {\n        note: 'Initial render'\n      })\n    });\n\n    // Warn about excessive re-renders\n    if (renderCount.current > threshold) {\n      console.warn(`‚ö†Ô∏è ${componentName} has rendered ${renderCount.current} times! This might indicate a performance issue.`, {\n        component: componentName,\n        renderCount: renderCount.current,\n        averageRenderTime: `${Math.round(totalTime / renderCount.current)}ms`,\n        suggestions: ['Check if props are being recreated on each render', 'Consider using React.memo() if props rarely change', 'Use useMemo() or useCallback() for expensive computations', 'Verify context providers are not causing unnecessary re-renders']\n      });\n    }\n\n    // Warn about rapid re-renders (less than 16ms apart - faster than 60fps)\n    if (timeSinceLastRender < 16 && renderCount.current > 1) {\n      console.warn(`‚ö° ${componentName} is re-rendering very rapidly (${timeSinceLastRender}ms since last render)`, {\n        component: componentName,\n        timeSinceLastRender: `${timeSinceLastRender}ms`,\n        suggestion: 'Consider debouncing state updates or using React.memo()'\n      });\n    }\n    lastRenderTime.current = currentTime;\n  });\n\n  // Return render statistics for debugging\n  return {\n    renderCount: renderCount.current,\n    getStats: () => ({\n      componentName,\n      renderCount: renderCount.current,\n      totalTime: Date.now() - startTime.current,\n      averageRenderTime: Math.round((Date.now() - startTime.current) / renderCount.current),\n      propsHistory: propsHistory.current\n    })\n  };\n};\n_s(useRenderTracker, \"q+X12AH1MQq3m+YwSoQUcFPauNI=\");\nexport default useRenderTracker;","map":{"version":3,"names":["useRef","useEffect","useRenderTracker","componentName","props","threshold","_s","renderCount","lastRenderTime","Date","now","propsHistory","startTime","process","env","NODE_ENV","current","currentTime","timeSinceLastRender","totalTime","currentProps","previousProps","length","changedProps","Object","keys","forEach","key","from","to","push","slice","hasChangedProps","logStyle","console","log","note","warn","component","averageRenderTime","Math","round","suggestions","suggestion","getStats"],"sources":["/Users/todoporunalma/Desktop/ol/corporacion_react/src/shared/hooks/useRenderTracker.js"],"sourcesContent":["import { useRef, useEffect } from 'react';\n\n/**\n * Development-only hook to track component re-renders and detect excessive re-rendering\n * @param {string} componentName - Name of the component being tracked\n * @param {Object} props - Component props to track changes (optional)\n * @param {number} threshold - Number of renders before warning (default: 10)\n */\nconst useRenderTracker = (componentName, props = {}, threshold = 10) => {\n  const renderCount = useRef(0);\n  const lastRenderTime = useRef(Date.now());\n  const propsHistory = useRef([]);\n  const startTime = useRef(Date.now());\n\n  useEffect(() => {\n    // Only run in development mode\n    if (process.env.NODE_ENV !== 'development') {\n      return;\n    }\n\n    renderCount.current += 1;\n    const currentTime = Date.now();\n    const timeSinceLastRender = currentTime - lastRenderTime.current;\n    const totalTime = currentTime - startTime.current;\n\n    // Track props changes\n    const currentProps = { ...props };\n    const previousProps = propsHistory.current[propsHistory.current.length - 1] || {};\n    \n    // Find changed props\n    const changedProps = {};\n    Object.keys(currentProps).forEach(key => {\n      if (currentProps[key] !== previousProps[key]) {\n        changedProps[key] = {\n          from: previousProps[key],\n          to: currentProps[key]\n        };\n      }\n    });\n\n    // Store current props for next comparison\n    propsHistory.current.push(currentProps);\n    \n    // Keep only last 5 prop snapshots to prevent memory leaks\n    if (propsHistory.current.length > 5) {\n      propsHistory.current = propsHistory.current.slice(-5);\n    }\n\n    // Log render information\n    const hasChangedProps = Object.keys(changedProps).length > 0;\n    const logStyle = renderCount.current > threshold ? 'color: red; font-weight: bold;' : 'color: blue;';\n    \n    console.log(\n      `%cüîÑ ${componentName} rendered (#${renderCount.current})`,\n      logStyle,\n      {\n        renderCount: renderCount.current,\n        timeSinceLastRender: `${timeSinceLastRender}ms`,\n        totalTime: `${totalTime}ms`,\n        ...(hasChangedProps && { changedProps }),\n        ...(renderCount.current === 1 && { note: 'Initial render' })\n      }\n    );\n\n    // Warn about excessive re-renders\n    if (renderCount.current > threshold) {\n      console.warn(\n        `‚ö†Ô∏è ${componentName} has rendered ${renderCount.current} times! This might indicate a performance issue.`,\n        {\n          component: componentName,\n          renderCount: renderCount.current,\n          averageRenderTime: `${Math.round(totalTime / renderCount.current)}ms`,\n          suggestions: [\n            'Check if props are being recreated on each render',\n            'Consider using React.memo() if props rarely change',\n            'Use useMemo() or useCallback() for expensive computations',\n            'Verify context providers are not causing unnecessary re-renders'\n          ]\n        }\n      );\n    }\n\n    // Warn about rapid re-renders (less than 16ms apart - faster than 60fps)\n    if (timeSinceLastRender < 16 && renderCount.current > 1) {\n      console.warn(\n        `‚ö° ${componentName} is re-rendering very rapidly (${timeSinceLastRender}ms since last render)`,\n        {\n          component: componentName,\n          timeSinceLastRender: `${timeSinceLastRender}ms`,\n          suggestion: 'Consider debouncing state updates or using React.memo()'\n        }\n      );\n    }\n\n    lastRenderTime.current = currentTime;\n  });\n\n  // Return render statistics for debugging\n  return {\n    renderCount: renderCount.current,\n    getStats: () => ({\n      componentName,\n      renderCount: renderCount.current,\n      totalTime: Date.now() - startTime.current,\n      averageRenderTime: Math.round((Date.now() - startTime.current) / renderCount.current),\n      propsHistory: propsHistory.current\n    })\n  };\n};\n\nexport default useRenderTracker;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}