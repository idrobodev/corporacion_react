{"ast":null,"code":"import axios from 'axios';\n\n// Configuración de la API de formatos - apunta al servicio dedicado de formatos\nconst FORMATOS_API_BASE_URL = process.env.REACT_APP_FORMATOS_API_URL || `${window.location.protocol}//${window.location.hostname}:8082`;\nconsole.log('🔧 FORMATOS_API_BASE_URL configurada como:', FORMATOS_API_BASE_URL);\nconsole.log('🔧 FORMATOS API DIAGNOSTICS:');\nconsole.log('  - REACT_APP_FORMATOS_API_URL:', process.env.REACT_APP_FORMATOS_API_URL);\nconsole.log('  - Fallback URL:', 'http://localhost:8001/api');\n\n// Crear instancia de axios para la API de formatos\nconst formatosClient = axios.create({\n  baseURL: FORMATOS_API_BASE_URL,\n  timeout: 30000,\n  withCredentials: false,\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  }\n});\n\n// Interceptor para manejar respuestas y errores\nformatosClient.interceptors.response.use(response => response, error => {\n  var _error$config, _error$response, _error$response2, _error$response3, _error$response4, _error$response5, _error$response6;\n  console.error('Error en formatos API:', (_error$config = error.config) === null || _error$config === void 0 ? void 0 : _error$config.url, (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status, error.message);\n\n  // Manejar errores específicos\n  if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 413) {\n    throw new Error('El archivo es demasiado grande (máximo 100MB)');\n  } else if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 409) {\n    var _error$response$data;\n    throw new Error(((_error$response$data = error.response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.detail) || 'Conflicto: el recurso ya existe');\n  } else if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 404) {\n    throw new Error('Recurso no encontrado');\n  } else if (((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : _error$response5.status) === 400) {\n    var _error$response$data2;\n    throw new Error(((_error$response$data2 = error.response.data) === null || _error$response$data2 === void 0 ? void 0 : _error$response$data2.detail) || 'Datos inválidos');\n  } else if (((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.status) === 500) {\n    throw new Error('Error interno del servidor');\n  }\n\n  // Error de red o desconocido\n  if (!error.response) {\n    throw new Error('No se puede conectar con el servidor de formatos');\n  }\n  throw error;\n});\nclass FormatosApiService {\n  // ==================== ARCHIVOS ====================\n\n  /**\n   * Lista archivos y carpetas en una ruta específica\n   * @param {string} path - Ruta a listar (opcional, default=\"\")\n   * @returns {Promise<{files: Array, folders: Array, path: string}>}\n   */\n  async listFiles(path = \"\") {\n    try {\n      const response = await formatosClient.get('/list', {\n        params: {\n          path\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error listando archivos:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Sube un archivo al servidor\n   * Los archivos se organizan automáticamente en carpetas por tipo\n   * @param {File} file - Archivo a subir\n   * @returns {Promise<Object>} Información del archivo subido\n   */\n  async uploadFile(file) {\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n      const response = await formatosClient.post('/upload', formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error subiendo archivo:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Descarga un archivo por su ID\n   * @param {number} fileId - ID del archivo\n   * @returns {Promise<Blob>} Archivo como blob\n   */\n  async downloadFile(fileId) {\n    try {\n      const response = await formatosClient.get(`/download/${fileId}`, {\n        responseType: 'blob'\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error descargando archivo:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Elimina un archivo por su ID\n   * @param {number} fileId - ID del archivo a eliminar\n   * @returns {Promise<Object>} Confirmación de eliminación\n   */\n  async deleteFile(fileId) {\n    try {\n      const response = await formatosClient.delete(`/${fileId}`);\n      return response.data;\n    } catch (error) {\n      console.error('Error eliminando archivo:', error);\n      throw error;\n    }\n  }\n\n  // ==================== CARPETAS ====================\n\n  /**\n   * Crea una nueva carpeta\n   * @param {string} nombre - Nombre de la carpeta\n   * @param {string} parentPath - Ruta del directorio padre (opcional)\n   * @returns {Promise<Object>} Información de la carpeta creada\n   */\n  async createFolder(nombre, parentPath = \"\") {\n    try {\n      const response = await formatosClient.post('/folders/create', {\n        nombre,\n        parentPath\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error creando carpeta:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Renombra una carpeta\n   * @param {string} oldName - Nombre actual de la carpeta\n   * @param {string} newName - Nuevo nombre de la carpeta\n   * @param {string} parentPath - Ruta del directorio padre\n   * @returns {Promise<Object>} Confirmación del cambio\n   */\n  async renameFolder(oldName, newName, parentPath = \"\") {\n    try {\n      const response = await formatosClient.put('/folders/rename', {\n        oldName,\n        newName,\n        parentPath\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error renombrando carpeta:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Elimina una carpeta por su ID\n   * @param {number} folderId - ID de la carpeta a eliminar\n   * @returns {Promise<Object>} Confirmación de eliminación\n   */\n  async deleteFolder(folderId) {\n    try {\n      const response = await formatosClient.delete(`/folders/${folderId}`);\n      return response.data;\n    } catch (error) {\n      console.error('Error eliminando carpeta:', error);\n      throw error;\n    }\n  }\n}\n\n// Exportar instancia única del servicio\nexport const formatosApi = new FormatosApiService();\nexport default formatosApi;","map":{"version":3,"names":["axios","FORMATOS_API_BASE_URL","process","env","REACT_APP_FORMATOS_API_URL","window","location","protocol","hostname","console","log","formatosClient","create","baseURL","timeout","withCredentials","headers","interceptors","response","use","error","_error$config","_error$response","_error$response2","_error$response3","_error$response4","_error$response5","_error$response6","config","url","status","message","Error","_error$response$data","data","detail","_error$response$data2","FormatosApiService","listFiles","path","get","params","uploadFile","file","formData","FormData","append","post","downloadFile","fileId","responseType","deleteFile","delete","createFolder","nombre","parentPath","renameFolder","oldName","newName","put","deleteFolder","folderId","formatosApi"],"sources":["/Users/todoporunalma/Desktop/ol/corporacion_react/src/shared/services/formatosApi.js"],"sourcesContent":["import axios from 'axios';\n\n// Configuración de la API de formatos - apunta al servicio dedicado de formatos\nconst FORMATOS_API_BASE_URL = process.env.REACT_APP_FORMATOS_API_URL ||\n  `${window.location.protocol}//${window.location.hostname}:8082`;\n\nconsole.log('🔧 FORMATOS_API_BASE_URL configurada como:', FORMATOS_API_BASE_URL);\nconsole.log('🔧 FORMATOS API DIAGNOSTICS:');\nconsole.log('  - REACT_APP_FORMATOS_API_URL:', process.env.REACT_APP_FORMATOS_API_URL);\nconsole.log('  - Fallback URL:', 'http://localhost:8001/api');\n\n// Crear instancia de axios para la API de formatos\nconst formatosClient = axios.create({\n  baseURL: FORMATOS_API_BASE_URL,\n  timeout: 30000,\n  withCredentials: false,\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json',\n  },\n});\n\n// Interceptor para manejar respuestas y errores\nformatosClient.interceptors.response.use(\n  (response) => response,\n  (error) => {\n    console.error('Error en formatos API:', error.config?.url, error.response?.status, error.message);\n\n    // Manejar errores específicos\n    if (error.response?.status === 413) {\n      throw new Error('El archivo es demasiado grande (máximo 100MB)');\n    } else if (error.response?.status === 409) {\n      throw new Error(error.response.data?.detail || 'Conflicto: el recurso ya existe');\n    } else if (error.response?.status === 404) {\n      throw new Error('Recurso no encontrado');\n    } else if (error.response?.status === 400) {\n      throw new Error(error.response.data?.detail || 'Datos inválidos');\n    } else if (error.response?.status === 500) {\n      throw new Error('Error interno del servidor');\n    }\n\n    // Error de red o desconocido\n    if (!error.response) {\n      throw new Error('No se puede conectar con el servidor de formatos');\n    }\n\n    throw error;\n  }\n);\n\nclass FormatosApiService {\n  // ==================== ARCHIVOS ====================\n\n  /**\n   * Lista archivos y carpetas en una ruta específica\n   * @param {string} path - Ruta a listar (opcional, default=\"\")\n   * @returns {Promise<{files: Array, folders: Array, path: string}>}\n   */\n  async listFiles(path = \"\") {\n    try {\n      const response = await formatosClient.get('/list', {\n        params: { path }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error listando archivos:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Sube un archivo al servidor\n   * Los archivos se organizan automáticamente en carpetas por tipo\n   * @param {File} file - Archivo a subir\n   * @returns {Promise<Object>} Información del archivo subido\n   */\n  async uploadFile(file) {\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n\n      const response = await formatosClient.post('/upload', formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data',\n        },\n      });\n\n      return response.data;\n    } catch (error) {\n      console.error('Error subiendo archivo:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Descarga un archivo por su ID\n   * @param {number} fileId - ID del archivo\n   * @returns {Promise<Blob>} Archivo como blob\n   */\n  async downloadFile(fileId) {\n    try {\n      const response = await formatosClient.get(`/download/${fileId}`, {\n        responseType: 'blob',\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error descargando archivo:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Elimina un archivo por su ID\n   * @param {number} fileId - ID del archivo a eliminar\n   * @returns {Promise<Object>} Confirmación de eliminación\n   */\n  async deleteFile(fileId) {\n    try {\n      const response = await formatosClient.delete(`/${fileId}`);\n      return response.data;\n    } catch (error) {\n      console.error('Error eliminando archivo:', error);\n      throw error;\n    }\n  }\n\n  // ==================== CARPETAS ====================\n\n  /**\n   * Crea una nueva carpeta\n   * @param {string} nombre - Nombre de la carpeta\n   * @param {string} parentPath - Ruta del directorio padre (opcional)\n   * @returns {Promise<Object>} Información de la carpeta creada\n   */\n  async createFolder(nombre, parentPath = \"\") {\n    try {\n      const response = await formatosClient.post('/folders/create', {\n        nombre,\n        parentPath\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error creando carpeta:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Renombra una carpeta\n   * @param {string} oldName - Nombre actual de la carpeta\n   * @param {string} newName - Nuevo nombre de la carpeta\n   * @param {string} parentPath - Ruta del directorio padre\n   * @returns {Promise<Object>} Confirmación del cambio\n   */\n  async renameFolder(oldName, newName, parentPath = \"\") {\n    try {\n      const response = await formatosClient.put('/folders/rename', {\n        oldName,\n        newName,\n        parentPath\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error renombrando carpeta:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Elimina una carpeta por su ID\n   * @param {number} folderId - ID de la carpeta a eliminar\n   * @returns {Promise<Object>} Confirmación de eliminación\n   */\n  async deleteFolder(folderId) {\n    try {\n      const response = await formatosClient.delete(`/folders/${folderId}`);\n      return response.data;\n    } catch (error) {\n      console.error('Error eliminando carpeta:', error);\n      throw error;\n    }\n  }\n}\n\n// Exportar instancia única del servicio\nexport const formatosApi = new FormatosApiService();\nexport default formatosApi;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}