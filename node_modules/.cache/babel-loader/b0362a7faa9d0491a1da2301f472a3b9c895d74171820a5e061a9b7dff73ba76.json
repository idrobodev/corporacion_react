{"ast":null,"code":"/**\n * Validation Utilities\n * Centralized validation functions for the application\n */\n\nimport { dbService } from '../services';\n\n/**\n * Validate that a documento number is unique for participantes\n * @param {string} numeroDocumento - Document number to validate\n * @param {number|null} participanteId - ID of current participante (for edit mode)\n * @returns {Promise<{isValid: boolean, error: string|null}>}\n */\nexport const validateParticipanteDocumentoUnico = async (numeroDocumento, participanteId = null) => {\n  try {\n    if (!numeroDocumento || !numeroDocumento.trim()) {\n      return {\n        isValid: false,\n        error: 'El número de documento es requerido'\n      };\n    }\n    const result = await dbService.getParticipantes();\n    if (result.data && Array.isArray(result.data)) {\n      const exists = result.data.some(p => {\n        const pId = p.id || p.id_participante;\n        return p.numero_documento === numeroDocumento && pId !== participanteId;\n      });\n      if (exists) {\n        return {\n          isValid: false,\n          error: 'El número de documento ya está registrado para otro participante'\n        };\n      }\n    }\n    return {\n      isValid: true,\n      error: null\n    };\n  } catch (err) {\n    console.error('Error validating participante documento:', err);\n    // Allow if validation fails to not block the user\n    return {\n      isValid: true,\n      error: null\n    };\n  }\n};\n\n/**\n * Validate that a documento number is unique for acudientes\n * @param {string} numeroDocumento - Document number to validate\n * @param {number|null} acudienteId - ID of current acudiente (for edit mode)\n * @returns {Promise<{isValid: boolean, error: string|null}>}\n */\nexport const validateAcudienteDocumentoUnico = async (numeroDocumento, acudienteId = null) => {\n  try {\n    if (!numeroDocumento || !numeroDocumento.trim()) {\n      return {\n        isValid: false,\n        error: 'El número de documento es requerido'\n      };\n    }\n    const result = await dbService.getAcudientes();\n    if (result.data && Array.isArray(result.data)) {\n      const exists = result.data.some(a => {\n        const aId = a.id || a.id_acudiente;\n        return a.numero_documento === numeroDocumento && aId !== acudienteId;\n      });\n      if (exists) {\n        return {\n          isValid: false,\n          error: 'El número de documento ya está registrado para otro acudiente'\n        };\n      }\n    }\n    return {\n      isValid: true,\n      error: null\n    };\n  } catch (err) {\n    console.error('Error validating acudiente documento:', err);\n    // Allow if validation fails to not block the user\n    return {\n      isValid: true,\n      error: null\n    };\n  }\n};\n\n/**\n * Validate email format\n * @param {string} email - Email to validate\n * @returns {{isValid: boolean, error: string|null}}\n */\nexport const validateEmail = email => {\n  if (!email || !email.trim()) {\n    return {\n      isValid: false,\n      error: 'El email es requerido'\n    };\n  }\n\n  // Basic email regex pattern\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(email)) {\n    return {\n      isValid: false,\n      error: 'El formato del email no es válido'\n    };\n  }\n  return {\n    isValid: true,\n    error: null\n  };\n};\n\n/**\n * Validate date format and ensure it's not in the future\n * @param {string} fecha - Date string to validate\n * @param {string} fieldName - Name of the field for error messages\n * @returns {{isValid: boolean, error: string|null}}\n */\nexport const validateFecha = (fecha, fieldName = 'fecha') => {\n  if (!fecha) {\n    return {\n      isValid: false,\n      error: `La ${fieldName} es requerida`\n    };\n  }\n  const date = new Date(fecha);\n  const today = new Date();\n\n  // Reset time to compare only dates\n  today.setHours(23, 59, 59, 999);\n\n  // Check if date is valid\n  if (!(date instanceof Date) || isNaN(date.getTime())) {\n    return {\n      isValid: false,\n      error: `La ${fieldName} no es válida`\n    };\n  }\n\n  // Check if date is not in the future\n  if (date > today) {\n    return {\n      isValid: false,\n      error: `La ${fieldName} no puede ser futura`\n    };\n  }\n  return {\n    isValid: true,\n    error: null\n  };\n};\n\n/**\n * Validate fecha_nacimiento specifically\n * @param {string} fechaNacimiento - Birth date to validate\n * @returns {{isValid: boolean, error: string|null}}\n */\nexport const validateFechaNacimiento = fechaNacimiento => {\n  return validateFecha(fechaNacimiento, 'fecha de nacimiento');\n};\n\n/**\n * Validate fecha_ingreso specifically\n * @param {string} fechaIngreso - Entry date to validate\n * @returns {{isValid: boolean, error: string|null}}\n */\nexport const validateFechaIngreso = fechaIngreso => {\n  return validateFecha(fechaIngreso, 'fecha de ingreso');\n};\n\n/**\n * Validate that a participante exists\n * @param {number} participanteId - ID of participante to validate\n * @returns {Promise<{isValid: boolean, error: string|null}>}\n */\nexport const validateParticipanteExists = async participanteId => {\n  try {\n    if (!participanteId) {\n      return {\n        isValid: false,\n        error: 'Debe seleccionar un participante'\n      };\n    }\n    const result = await dbService.getParticipantes();\n    if (result.data && Array.isArray(result.data)) {\n      const exists = result.data.some(p => (p.id_participante || p.id) === parseInt(participanteId));\n      if (!exists) {\n        return {\n          isValid: false,\n          error: 'El participante seleccionado no existe'\n        };\n      }\n    }\n    return {\n      isValid: true,\n      error: null\n    };\n  } catch (err) {\n    console.error('Error validating participante exists:', err);\n    return {\n      isValid: false,\n      error: 'Error al validar el participante'\n    };\n  }\n};\n\n/**\n * Validate that a sede exists\n * @param {number} sedeId - ID of sede to validate\n * @returns {Promise<{isValid: boolean, error: string|null}>}\n */\nexport const validateSedeExists = async sedeId => {\n  try {\n    if (!sedeId) {\n      return {\n        isValid: false,\n        error: 'Debe seleccionar una sede'\n      };\n    }\n    const result = await dbService.getSedes();\n    if (result.data && Array.isArray(result.data)) {\n      const exists = result.data.some(s => (s.id_sede || s.id) === parseInt(sedeId));\n      if (!exists) {\n        return {\n          isValid: false,\n          error: 'La sede seleccionada no existe'\n        };\n      }\n    }\n    return {\n      isValid: true,\n      error: null\n    };\n  } catch (err) {\n    console.error('Error validating sede exists:', err);\n    return {\n      isValid: false,\n      error: 'Error al validar la sede'\n    };\n  }\n};\n\n/**\n * Validate that an acudiente exists\n * @param {number} acudienteId - ID of acudiente to validate\n * @returns {Promise<{isValid: boolean, error: string|null}>}\n */\nexport const validateAcudienteExists = async acudienteId => {\n  try {\n    if (!acudienteId) {\n      return {\n        isValid: false,\n        error: 'Debe seleccionar un acudiente'\n      };\n    }\n    const result = await dbService.getAcudientes();\n    if (result.data && Array.isArray(result.data)) {\n      const exists = result.data.some(a => (a.id_acudiente || a.id) === parseInt(acudienteId));\n      if (!exists) {\n        return {\n          isValid: false,\n          error: 'El acudiente seleccionado no existe'\n        };\n      }\n    }\n    return {\n      isValid: true,\n      error: null\n    };\n  } catch (err) {\n    console.error('Error validating acudiente exists:', err);\n    return {\n      isValid: false,\n      error: 'Error al validar el acudiente'\n    };\n  }\n};\n\n/**\n * Validate mensualidad relationships (participante and acudiente must exist)\n * @param {number} participanteId - ID of participante\n * @param {number} acudienteId - ID of acudiente\n * @returns {Promise<{isValid: boolean, error: string|null}>}\n */\nexport const validateMensualidadRelations = async (participanteId, acudienteId) => {\n  // Validate participante\n  const participanteValidation = await validateParticipanteExists(participanteId);\n  if (!participanteValidation.isValid) {\n    return participanteValidation;\n  }\n\n  // Validate acudiente\n  const acudienteValidation = await validateAcudienteExists(acudienteId);\n  if (!acudienteValidation.isValid) {\n    return acudienteValidation;\n  }\n  return {\n    isValid: true,\n    error: null\n  };\n};","map":{"version":3,"names":["dbService","validateParticipanteDocumentoUnico","numeroDocumento","participanteId","trim","isValid","error","result","getParticipantes","data","Array","isArray","exists","some","p","pId","id","id_participante","numero_documento","err","console","validateAcudienteDocumentoUnico","acudienteId","getAcudientes","a","aId","id_acudiente","validateEmail","email","emailRegex","test","validateFecha","fecha","fieldName","date","Date","today","setHours","isNaN","getTime","validateFechaNacimiento","fechaNacimiento","validateFechaIngreso","fechaIngreso","validateParticipanteExists","parseInt","validateSedeExists","sedeId","getSedes","s","id_sede","validateAcudienteExists","validateMensualidadRelations","participanteValidation","acudienteValidation"],"sources":["/Users/todoporunalma/Desktop/ol/corporacion_react/src/shared/utils/validationUtils.js"],"sourcesContent":["/**\n * Validation Utilities\n * Centralized validation functions for the application\n */\n\nimport { dbService } from '../services';\n\n/**\n * Validate that a documento number is unique for participantes\n * @param {string} numeroDocumento - Document number to validate\n * @param {number|null} participanteId - ID of current participante (for edit mode)\n * @returns {Promise<{isValid: boolean, error: string|null}>}\n */\nexport const validateParticipanteDocumentoUnico = async (numeroDocumento, participanteId = null) => {\n  try {\n    if (!numeroDocumento || !numeroDocumento.trim()) {\n      return { isValid: false, error: 'El número de documento es requerido' };\n    }\n\n    const result = await dbService.getParticipantes();\n    if (result.data && Array.isArray(result.data)) {\n      const exists = result.data.some(p => {\n        const pId = p.id || p.id_participante;\n        return p.numero_documento === numeroDocumento && pId !== participanteId;\n      });\n      \n      if (exists) {\n        return { \n          isValid: false, \n          error: 'El número de documento ya está registrado para otro participante' \n        };\n      }\n    }\n    \n    return { isValid: true, error: null };\n  } catch (err) {\n    console.error('Error validating participante documento:', err);\n    // Allow if validation fails to not block the user\n    return { isValid: true, error: null };\n  }\n};\n\n/**\n * Validate that a documento number is unique for acudientes\n * @param {string} numeroDocumento - Document number to validate\n * @param {number|null} acudienteId - ID of current acudiente (for edit mode)\n * @returns {Promise<{isValid: boolean, error: string|null}>}\n */\nexport const validateAcudienteDocumentoUnico = async (numeroDocumento, acudienteId = null) => {\n  try {\n    if (!numeroDocumento || !numeroDocumento.trim()) {\n      return { isValid: false, error: 'El número de documento es requerido' };\n    }\n\n    const result = await dbService.getAcudientes();\n    if (result.data && Array.isArray(result.data)) {\n      const exists = result.data.some(a => {\n        const aId = a.id || a.id_acudiente;\n        return a.numero_documento === numeroDocumento && aId !== acudienteId;\n      });\n      \n      if (exists) {\n        return { \n          isValid: false, \n          error: 'El número de documento ya está registrado para otro acudiente' \n        };\n      }\n    }\n    \n    return { isValid: true, error: null };\n  } catch (err) {\n    console.error('Error validating acudiente documento:', err);\n    // Allow if validation fails to not block the user\n    return { isValid: true, error: null };\n  }\n};\n\n/**\n * Validate email format\n * @param {string} email - Email to validate\n * @returns {{isValid: boolean, error: string|null}}\n */\nexport const validateEmail = (email) => {\n  if (!email || !email.trim()) {\n    return { isValid: false, error: 'El email es requerido' };\n  }\n\n  // Basic email regex pattern\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  \n  if (!emailRegex.test(email)) {\n    return { \n      isValid: false, \n      error: 'El formato del email no es válido' \n    };\n  }\n\n  return { isValid: true, error: null };\n};\n\n/**\n * Validate date format and ensure it's not in the future\n * @param {string} fecha - Date string to validate\n * @param {string} fieldName - Name of the field for error messages\n * @returns {{isValid: boolean, error: string|null}}\n */\nexport const validateFecha = (fecha, fieldName = 'fecha') => {\n  if (!fecha) {\n    return { isValid: false, error: `La ${fieldName} es requerida` };\n  }\n\n  const date = new Date(fecha);\n  const today = new Date();\n  \n  // Reset time to compare only dates\n  today.setHours(23, 59, 59, 999);\n\n  // Check if date is valid\n  if (!(date instanceof Date) || isNaN(date.getTime())) {\n    return { \n      isValid: false, \n      error: `La ${fieldName} no es válida` \n    };\n  }\n\n  // Check if date is not in the future\n  if (date > today) {\n    return { \n      isValid: false, \n      error: `La ${fieldName} no puede ser futura` \n    };\n  }\n\n  return { isValid: true, error: null };\n};\n\n/**\n * Validate fecha_nacimiento specifically\n * @param {string} fechaNacimiento - Birth date to validate\n * @returns {{isValid: boolean, error: string|null}}\n */\nexport const validateFechaNacimiento = (fechaNacimiento) => {\n  return validateFecha(fechaNacimiento, 'fecha de nacimiento');\n};\n\n/**\n * Validate fecha_ingreso specifically\n * @param {string} fechaIngreso - Entry date to validate\n * @returns {{isValid: boolean, error: string|null}}\n */\nexport const validateFechaIngreso = (fechaIngreso) => {\n  return validateFecha(fechaIngreso, 'fecha de ingreso');\n};\n\n/**\n * Validate that a participante exists\n * @param {number} participanteId - ID of participante to validate\n * @returns {Promise<{isValid: boolean, error: string|null}>}\n */\nexport const validateParticipanteExists = async (participanteId) => {\n  try {\n    if (!participanteId) {\n      return { isValid: false, error: 'Debe seleccionar un participante' };\n    }\n\n    const result = await dbService.getParticipantes();\n    if (result.data && Array.isArray(result.data)) {\n      const exists = result.data.some(p => \n        (p.id_participante || p.id) === parseInt(participanteId)\n      );\n      \n      if (!exists) {\n        return { \n          isValid: false, \n          error: 'El participante seleccionado no existe' \n        };\n      }\n    }\n    \n    return { isValid: true, error: null };\n  } catch (err) {\n    console.error('Error validating participante exists:', err);\n    return { isValid: false, error: 'Error al validar el participante' };\n  }\n};\n\n/**\n * Validate that a sede exists\n * @param {number} sedeId - ID of sede to validate\n * @returns {Promise<{isValid: boolean, error: string|null}>}\n */\nexport const validateSedeExists = async (sedeId) => {\n  try {\n    if (!sedeId) {\n      return { isValid: false, error: 'Debe seleccionar una sede' };\n    }\n\n    const result = await dbService.getSedes();\n    if (result.data && Array.isArray(result.data)) {\n      const exists = result.data.some(s => \n        (s.id_sede || s.id) === parseInt(sedeId)\n      );\n      \n      if (!exists) {\n        return { \n          isValid: false, \n          error: 'La sede seleccionada no existe' \n        };\n      }\n    }\n    \n    return { isValid: true, error: null };\n  } catch (err) {\n    console.error('Error validating sede exists:', err);\n    return { isValid: false, error: 'Error al validar la sede' };\n  }\n};\n\n/**\n * Validate that an acudiente exists\n * @param {number} acudienteId - ID of acudiente to validate\n * @returns {Promise<{isValid: boolean, error: string|null}>}\n */\nexport const validateAcudienteExists = async (acudienteId) => {\n  try {\n    if (!acudienteId) {\n      return { isValid: false, error: 'Debe seleccionar un acudiente' };\n    }\n\n    const result = await dbService.getAcudientes();\n    if (result.data && Array.isArray(result.data)) {\n      const exists = result.data.some(a => \n        (a.id_acudiente || a.id) === parseInt(acudienteId)\n      );\n      \n      if (!exists) {\n        return { \n          isValid: false, \n          error: 'El acudiente seleccionado no existe' \n        };\n      }\n    }\n    \n    return { isValid: true, error: null };\n  } catch (err) {\n    console.error('Error validating acudiente exists:', err);\n    return { isValid: false, error: 'Error al validar el acudiente' };\n  }\n};\n\n/**\n * Validate mensualidad relationships (participante and acudiente must exist)\n * @param {number} participanteId - ID of participante\n * @param {number} acudienteId - ID of acudiente\n * @returns {Promise<{isValid: boolean, error: string|null}>}\n */\nexport const validateMensualidadRelations = async (participanteId, acudienteId) => {\n  // Validate participante\n  const participanteValidation = await validateParticipanteExists(participanteId);\n  if (!participanteValidation.isValid) {\n    return participanteValidation;\n  }\n\n  // Validate acudiente\n  const acudienteValidation = await validateAcudienteExists(acudienteId);\n  if (!acudienteValidation.isValid) {\n    return acudienteValidation;\n  }\n\n  return { isValid: true, error: null };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}